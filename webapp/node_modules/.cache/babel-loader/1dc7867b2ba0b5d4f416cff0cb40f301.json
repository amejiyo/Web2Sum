{"ast":null,"code":"import _classCallCheck from \"/Users/amejiyopakapak/Documents/NLP/Web2TextSum/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/amejiyopakapak/Documents/NLP/Web2TextSum/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/amejiyopakapak/Documents/NLP/Web2TextSum/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/amejiyopakapak/Documents/NLP/Web2TextSum/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/amejiyopakapak/Documents/NLP/Web2TextSum/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/amejiyopakapak/Documents/NLP/Web2TextSum/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertiesChanged } from './properties-changed.js';\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nvar nativeProperties = {};\nvar proto = HTMLElement.prototype;\nwhile (proto) {\n  var props = Object.getOwnPropertyNames(proto);\n  for (var i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\nvar isTrustedType = function () {\n  if (!window.trustedTypes) {\n    return function () {\n      return false;\n    };\n  }\n  return function (val) {\n    return trustedTypes.isHTML(val) || trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);\n  };\n}();\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    var value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport var PropertyAccessors = dedupingMixin(function (superClass) {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n  var base = PropertiesChanged(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n  var PropertyAccessors = /*#__PURE__*/function (_base) {\n    _inherits(PropertyAccessors, _base);\n    function PropertyAccessors() {\n      _classCallCheck(this, PropertyAccessors);\n      return _possibleConstructorReturn(this, _getPrototypeOf(PropertyAccessors).apply(this, arguments));\n    }\n    _createClass(PropertyAccessors, [{\n      key: \"_initializeProperties\",\n      /**\n       * Overrides PropertiesChanged implementation to initialize values for\n       * accessors created for values that already existed on the element\n       * prototype.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n      value: function _initializeProperties() {\n        if (this.__dataProto) {\n          this._initializeProtoProperties(this.__dataProto);\n          this.__dataProto = null;\n        }\n        _get(_getPrototypeOf(PropertyAccessors.prototype), \"_initializeProperties\", this).call(this);\n      }\n      /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_initializeProtoProperties\",\n      value: function _initializeProtoProperties(props) {\n        for (var p in props) {\n          this._setProperty(p, props[p]);\n        }\n      }\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n       *     element\n       *\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_ensureAttribute\",\n      value: function _ensureAttribute(attribute, value) {\n        var el = /** @type {!HTMLElement} */this;\n        if (!el.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(el, value, attribute);\n        }\n      }\n      /**\n       * Overrides PropertiesChanged implemention to serialize objects as JSON.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property\n       *     value.\n       * @override\n       */\n    }, {\n      key: \"_serializeValue\",\n      value: function _serializeValue(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value) {\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              if (isTrustedType(value)) {\n                /**\n                 * Here `value` isn't actually a string, but it should be\n                 * passed into APIs that normally expect a string, like\n                 * elem.setAttribute.\n                 */\n                return (/** @type {?} */value\n                );\n              }\n              try {\n                return JSON.stringify(value);\n              } catch (x) {\n                return '';\n              }\n            }\n          default:\n            return _get(_getPrototypeOf(PropertyAccessors.prototype), \"_serializeValue\", this).call(this, value);\n        }\n      }\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       *\n       * @param {?string} value Attribute value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       * @override\n       */\n    }, {\n      key: \"_deserializeValue\",\n      value: function _deserializeValue(value, type) {\n        /**\n         * @type {*}\n         */\n        var outValue;\n        switch (type) {\n          case Object:\n            try {\n              outValue = JSON.parse( /** @type {string} */value);\n            } catch (x) {\n              // allow non-JSON literals like Strings and Numbers\n              outValue = value;\n            }\n            break;\n          case Array:\n            try {\n              outValue = JSON.parse( /** @type {string} */value);\n            } catch (x) {\n              outValue = null;\n              console.warn(\"Polymer::Attributes: couldn't decode Array as JSON: \".concat(value));\n            }\n            break;\n          case Date:\n            outValue = isNaN(value) ? String(value) : Number(value);\n            outValue = new Date(outValue);\n            break;\n          default:\n            outValue = _get(_getPrototypeOf(PropertyAccessors.prototype), \"_deserializeValue\", this).call(this, value, type);\n            break;\n        }\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n      /**\n       * Overrides PropertiesChanged implementation to save existing prototype\n       * property value so that it can be reset.\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       *\n       * When calling on a prototype, any overwritten values are saved in\n       * `__dataProto`, and it is up to the subclasser to decide how/when\n       * to set those properties back into the accessor.  When calling on an\n       * instance, the overwritten value is set via `_setPendingProperty`,\n       * and the user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       * @protected\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_definePropertyAccessor\",\n      value: function _definePropertyAccessor(property, readOnly) {\n        saveAccessorValue(this, property);\n        _get(_getPrototypeOf(PropertyAccessors.prototype), \"_definePropertyAccessor\", this).call(this, property, readOnly);\n      }\n      /**\n       * Returns true if this library created an accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if an accessor was created\n       * @override\n       */\n    }, {\n      key: \"_hasAccessor\",\n      value: function _hasAccessor(property) {\n        return this.__dataHasAccessor && this.__dataHasAccessor[property];\n      }\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_isPropertyPending\",\n      value: function _isPropertyPending(prop) {\n        return Boolean(this.__dataPending && prop in this.__dataPending);\n      }\n    }], [{\n      key: \"createPropertiesForAttributes\",\n      /**\n       * Generates property accessors for all attributes in the standard\n       * static `observedAttributes` array.\n       *\n       * Attribute names are mapped to property names using the `dash-case` to\n       * `camelCase` convention\n       *\n       * @return {void}\n       * @nocollapse\n       */\n      value: function createPropertiesForAttributes() {\n        var a$ = /** @type {?} */this.observedAttributes;\n        for (var _i = 0; _i < a$.length; _i++) {\n          this.prototype._createPropertyAccessor(dashToCamelCase(a$[_i]));\n        }\n      }\n      /**\n       * Returns an attribute name that corresponds to the given property.\n       * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"attributeNameForProperty\",\n      value: function attributeNameForProperty(property) {\n        return camelToDashCase(property);\n      }\n    }]);\n    return PropertyAccessors;\n  }(base);\n  return PropertyAccessors;\n});","map":null,"metadata":{},"sourceType":"module"}